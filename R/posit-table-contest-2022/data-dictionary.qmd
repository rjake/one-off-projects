---
title: "Untitled"
format: 
  html:
    page-layout: custom
    theme: lumen
server: shiny
execute: 
  echo: false
  warning: false
---


```{r input-demo}
#| eval: !expr interactive()

input <-
  list(
    col_name = "cust zip",
    table_name = "",
    search_type = "Table"
  )

shiny::reactiveConsole(enabled = TRUE)

table_search <- function() input$table_name
col_search <- function() input$col_name
```

```{r workspace}
#| context: setup

library(tidyverse)
library(shinyWidgets)
library(shiny)
library(DT)
library(glue)

raw_data <- 
  read_rds("salika.Rds") |> 
  mutate_if(is.character, as.factor)
```

```{r functions}
#| context: setup
base_datatable <- function(df, ...) {
  datatable(
    df,
    #filter = "top",
    rownames = FALSE,
    escape = FALSE,
    class = list(stripe = FALSE),
    options =
      list(
        ...,
        dom = "Brtip",
        deferRender = FALSE,
        scrollY = 540,
        scroller = TRUE,
        scrollX = TRUE,
        fixedHeader = FALSE,
        pageLength = nrow(df),
        lengthChange = FALSE
      )
  )
}

extract_bold <- function(string, pattern) {
  # string <- "am - cyl - disp - hp"
  # pattern <- "cyl hp"
  
  bold_pattern <- 
    glue(
      "(?i)({x})",
      x = str_replace_all(pattern, " ", "|")
    )
  
  string |> 
    str_replace_all(
      bold_pattern, 
      #"<strong>\\1</strong>"
      '<span style="color:dodgerblue;font-weight:bold;">\\1</span>'
    )
}
```

```{r ui}
#| context: setup

table_name <-
  textInput(
    "table_name",
    label = "Table(s): regex supported",
    placeholder = "type table names"
  )


col_name <-
  textInput(
    "col_name",
    label = "Column(s): fragments & spaces",
    placeholder = "type column names",
    value = "cust"
  )

search_type <-
  radioGroupButtons(
    "search_type",
    label = "One row per",
    choices = c("Table", "Column"),
    status = "primary",
    direction = "horizontal"
  )

fluidPage(
  fluidRow(
    column(3, table_name),
    column(5, col_name),
    column(2, search_type)
  ),
  DTOutput("table")
)
```


```{r}
library(reactable)

js_filter <- # Filter by case-insensitive text match
  JS(
    "function(rows, columnId, filterValue) {
        let pattern = new RegExp(filterValue.replace(' ', '.*'), 'i')
      
        return rows.filter(
          function(row) {
            return pattern.test(row.values[columnId])
          }
        )
    }"
  )

js_match_style <-
  JS(
    "function(cellInfo) {
        let x = cellInfo.value
        let filter_value = cellInfo.filterValue.replace(' ', '|')
        let capture_group = '(' + filter_value + ')'
        let pattern = RegExp(capture_group, 'gi')
        return x.replace(pattern, '<b>$1</b>')
      }"
  )

reactable(
  df |> rename(table = table_name),
  columns = list(
    # table = colDef(
    #   html = TRUE,
    #   filterable = TRUE, 
    #   filterMethod = js_filter,
    #   cell = js_match_style
    # ),
    field = colDef(
      html = TRUE,
      filterable = TRUE, 
      filterMethod = js_filter,
      cell = 
        JS(
          "function(cellInfo) {
            let x = cellInfo.value
            let filter_value = cellInfo.filterValue
            return RegExp(filterValue.replace(' ', '.*'), 'i')
            //let y = cellInfo.filterValue.id
            //let filter_value = 'cust zip'.replace(' ', '|')
            let capture_group = '(' + filter_value + ')'
            let pattern = RegExp(capture_group, 'gi')
            return x.replace(pattern, '<b>$1</b>')
            //return filter_value
            //return(x)
          }"
        )
    )
  ),
  defaultPageSize = 5
)
```

tibble(
  orig = head(sentences, 3),
  text = orig
) |> 
reactable(
  columns = list(
  text = colDef(
    html = TRUE,
    filterable = TRUE,
    filterMethod = JS(
    "function(rows, columnId, filterValue) {
        let pattern = new RegExp(filterValue.replace(' ', '.*'), 'i')
      
        return rows.filter(
          function(row) {
            return pattern.test(row.values[columnId])
          }
        )
    }"
  ),
    cell = JS(
      "function(cellInfo) {
        let x = cellInfo.value
        let y = '(' + cellInfo.filterValue + ')'
        let pattern = RegExp(y, 'i')
        return x.replace(pattern, '<b>$1</b>')
      }"
    )
  )
))



library(reactable)
library(tidyverse)

tibble(
  orig = head(sentences, 3),
  text = orig
) |> 
reactable(
  columns = list(
  text = colDef(
    html = TRUE,
    filterable = TRUE,
    cell = JS(
      "function(cellInfo) {
        let x = cellInfo.value
        let y = '(' + cellInfo.filterValue + ')'
        let pattern = RegExp(y, 'i')
        return x.replace(pattern, '<b>$1</b>')
      }"
    )
  )
))


treactable(
  iris[c(1, 51, 101), 3:5], 
  columns = list(
  Species = colDef(
    html = TRUE,
    filterable = TRUE,
    #filterMethod = js_filter,
    cell = JS(
      "function(cellInfo, filterValue) {
        //const x = cellInfo.value
        const y = RegExp(filterValue, 'i')
        //return `<b>${ y.value }</b>`   //cellInfo.value
        //const x =  RegExp('setosa'.replace('(set|a)', '<b>$1</b>'))
        //return `${ 'setosa'.replace(/y/g, 'XXX') }`
        return filterValue.id
      }"
    )
  )
))

const x =  RegExp('setosa'.replace('(set|a)', 'XXX'))
return `${ 'setosa'.replace('set', 'XXX') }`


```

```{r server}
#| context: server
prepare_regex <- function(x) {
  # x <- "a  b c"
  #entered <- ifelse(x == "", ".*", x)
  
  pattern <-
   # entered |> 
    str_replace_all(x, "\\s+", "|")
   find <- str_replace_all(x, "\\s+", ".*")
  
  list(
    bold = glue("(?i){pattern}"),
    find = glue("(?i){find}")
  )
}

# render table ----
output$table <- renderDT({
  table_regex <- prepare_regex(input$table_name)#table_search())
  column_regex <- prepare_regex(input$col_name)#col_search())
  
  
  # multi_col_entered <- length(column_all) > 1
  column_search_selected <- input$search_type == "Column"

  # print(use_column_view)
  # print(input$search_type)
  # print(column_all)

  # which dataset to use
  if (column_search_selected) {
    base_data <- raw_data
  } else {
    base_data <-
      raw_data |>
      group_by(table_name) |>
      summarise(field = paste(sort(field), collapse = " • ")) |>
      ungroup()
  }


  df <-
    base_data |>
    filter(
      str_detect(table_name, table_regex$find),
      str_detect(field, column_regex$find)
    )


  # final manipulation
  if (column_search_selected) {
    base_datatable(df)
  } else {
    # bold text if column search != ".*"
    df |>
      mutate(field = map_chr(field, extract_bold, column_regex$bold)) |>
      base_datatable(
        autoWidth = TRUE,
        columnDefs = list(
          list(targets = c(0), visible = TRUE, width = "10%"),
          list(targets = c(1), visible = TRUE, width = "80%")
        )
      )
  }
})

```


```{r EXIT___}
knitr::knit_exit()
```

```{r server-orig}
#| context: server

# table_search <- debounce(reactive(input$table_name), 1000)
# col_search <- debounce(reactive(input$col_name), 2000)



observeEvent(c(input$col_name, input$table_name, input$search_type), {
  output$table <- DT::renderDT(
    server = TRUE,
    expr = {
      print(reactiveValuesToList(input))
      print(input$search_type)
  
      table_regex <- prepare_regex(input$table_name)#table_search())
      column_regex <- prepare_regex(input$col_name)#col_search())
  
  
      # multi_col_entered <- length(column_all) > 1
      column_search_selected <- input$search_type == "Column"
  
      # print(use_column_view)
      # print(input$search_type)
      # print(column_all)
  
      # which dataset to use
      if (column_search_selected) {
        base_data <- raw_data
      } else {
        base_data <-
          raw_data |>
          group_by(table_name) |>
          summarise(field = paste(sort(field), collapse = " • ")) |>
          ungroup()
      }
  
  
      df <-
        base_data |>
        filter(
          str_detect(table_name, table_regex),
          str_detect(field, column_regex)
        )
  
  
      # final manipulation
      if (column_search_selected) {
        base_datatable(df)
      } else {
        # bold text if column search != ".*"
        df |>
          mutate(field = map_chr(field, extract_bold, column_regex)) |>
          base_datatable(
            autoWidth = TRUE,
            columnDefs = list(
              list(targets = c(0), visible = TRUE, width = "10%"),
              list(targets = c(1), visible = TRUE, width = "80%")
            )
          )
      }
    }
  )
})


# final_df |> 
#   reactable::reactable(
#     columns = list(
#       field = colDef(html = TRUE)
#     )
#   )
```


# TODO:
* see regex filter option in `reactable`
https://glin.github.io/reactable/articles/custom-filtering.html#regular-expression-pattern-filtering
* formatting
https://glin.github.io/reactable/articles/custom-rendering.html
* observable?
  https://glin.quarto.pub/observable-reactable/



```{r}
library(shiny)
library(DT)

textInput("n", "Max value", value = "80")
DT::DTOutput("table")
```

```{r}
#| context: server
library(shiny)
library(DT)
output$table <- renderDT({
  faithful |> 
    dplyr::filter(waiting <= as.integer(input$n)) |> 
    dplyr::count() |> 
    DT::datatable()
})
```
